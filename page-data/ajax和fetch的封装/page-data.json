{"componentChunkName":"component---src-templates-blog-post-js","path":"/ajax和fetch的封装/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"a96525ee-d35b-519f-b6c5-8485a59c20b5","excerpt":"一、ajax和fetch相同点 两者都是浏览器实现的用于和服务器进行异步通信的接口. 两者都可以实现不刷新页面的情况下局部渲染. 二、ajax和fetch的区别 ajax是通过浏览器中的XMLHttpRequest(IE5 或者IE6时ActiveXObject(‘Microsoft.XMLHTTP…","html":"<h1>一、ajax和fetch相同点</h1>\n<ol>\n<li>两者都是浏览器实现的用于和服务器进行异步通信的接口.</li>\n<li>两者都可以实现不刷新页面的情况下局部渲染.</li>\n</ol>\n<h1>二、ajax和fetch的区别</h1>\n<ol>\n<li>ajax是通过浏览器中的XMLHttpRequest(IE5 或者IE6时ActiveXObject(‘Microsoft.XMLHTTP’))对象实现的。</li>\n<li>fetch返回一个promise对象</li>\n<li>fetch跨域时不会带cookie，需要手动指定credentials: ‘include’</li>\n<li>fetch()返回的promise将不会拒绝http的错误状态，即使返回的响应时404或者500</li>\n</ol>\n<h1>三、ajax的封装实现</h1>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const ajax = (obj) =&gt; {\n    obj = obj || {};\n    obj.type = obj.type.toUpperCase() || &quot;POST&quot;;\n    obj.url = obj.url || &#39;&#39;;\n    obj.async = obj.async || true;\n    obj.data = obj.data || null;\n    obj.success = obj.success || function () {};\n    obj.error = obj.error || function () {};\n    let xmlHttp = null;\n    if(XMLHttpRequest) {\n        xmlHttp = new XMLHttpRequest();\n    } else {\n        xmlHttp = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);\n    }\n    let pramas = [];\n    for(let key in obj.data) {\n        pramas.push(key + &#39;=&#39; + obj.data[key]);\n    }\n    let reqData = pramas.join(&#39;&amp;&#39;);\n    if(obj.type == &#39;POST&#39;) {\n        xmlHttp.open(obj.type, obj.url, obj.async);\n        xmlHttp.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-wwww-form-urlencoded;charset=utf-8&#39;);\n        xmlHttp.send(reqData);\n    } else if(obj.type == &#39;GET&#39;) {\n        xmlHttp.open(obj.type, obj.url+&#39;?&#39;+reqData, obj.async);\n        xmlHttp.send();\n    }\n    xmlHttp.onreadystatechange = () =&gt; {\n        if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) {\n            obj.success(xmlHttp.responseText);\n        } else {\n            obj.error(xmlHttp.responseText);\n        }\n    }\n}\nexport { ajax }</code></pre></div>\n<h1>四、结合async的fetch封装实现</h1>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import _ from &#39;lodash&#39;;\nimport &quot;isomorphic-fetch&quot;;\nimport &quot;es6-promise&quot;;\n// 封装fetch\nclass httpFetch {\n    // 检查响应状态\n    checkStatus(response) {\n        if(response.status &gt;= 200 &amp;&amp; response.status &lt; 300) { // 响应成功\n            return response;\n        }\n        if(response.status === 301 || response.status === 302) { // 重定向\n            window.location = response.headers.get(&#39;Location&#39;);\n        }\n        const error = new Error(response.statusText);\n        error.data = response;\n        throw error;\n    }\n\n    // 解析返回的结果\n    async parseResult(response) {\n        console.log(&#39;parseResult response:&#39;,response);\n        const contentType = response.headers.get(&#39;Content-Type&#39;);\n        if(contentType !== null) {\n            if(contentType.indexOf(&#39;text&#39;) &gt; -1) {\n                return await response.text();\n            }\n            if(contentType.indexOf(&#39;form&#39;) &gt; -1) {\n                return await response.formData();\n            }\n            if(contentType.indexOf(&#39;video&#39;) &gt; -1) {\n                return await response.blob();\n            }\n            if(contentType.indexOf(&#39;json&#39;) &gt; -1) {\n                return await response.json();\n            }\n        }\n        return await response.text();\n    }\n\n    // 组合判断状态和结果解析\n    async processResult(response) {\n        let _response = this.checkStatus(response);\n        _response = await this.parseResult(_response);\n        return _response;\n    }\n\n    /**\n     * 序列化参数 (get)\n     * @param {any} obj\n     * @returns\n     */\n    serialiseObject (obj) {\n        const prefix = &#39;?&#39;;\n        if (obj &amp;&amp; Object.keys(obj).length) {\n        return prefix + Object.keys(obj).map(key =&gt;\n            `${key}=${encodeURIComponent(obj[key])}`\n        ).join(&#39;&amp;&#39;)\n        }\n        return &#39;&#39;\n    }\n  \n    // 封装fetch的request请求\n    async _request(url, init, headers = {}, config = {}) {\n        try {\n            let options = _.assign(\n                {\n                    credentials: &#39;include&#39;, // 允许跨域\n                },\n                init\n            );\n            options.headers = Object.assign({}, options.headers || {}, headers || {});\n            let response = await fetch(url, options);\n            response = await this.processResult(response);\n            return response;\n        } catch(err) {\n            throw err;\n            return null;\n        }\n    }\n\n    // get请求\n    async get(api, data = {}, headers = {}, config = {}) {\n        const query = _.isEmpty(data) ? &#39;&#39; : serialiseObject(data);\n        return await this._request(`${api}${query}`, headers, {}, config);\n    }\n\n    // post请求\n    async post(api, data = {}, headers = {}, config = {}) {\n        const _headers = {\n            &#39;Content-Type&#39;: &#39;application/x-wwww-form-urlencoded&#39;,\n            ...headers,\n        };\n        let formBody = null;\n        if(_headers[&#39;Content-Type&#39;] &amp;&amp; _headers[&#39;Content-Type&#39;].indexOf(&#39;application/x-www-form-urlencoded&#39;) &gt; -1) {\n            formBody = new URLSearchParams();\n            for (let key in data) {\n                if(typeof(data[key] === &#39;object&#39;)) {\n                    formBody.append(key, JSON.stringify(data[key]));\n                } else {\n                    formBody.append(key, data[key]);\n                }\n            }\n        }\n        return await this._request(\n            api,\n            {\n                method: &#39;POST&#39;,\n                headers: _headers,\n                body: formBody,\n            },\n            {},\n            config,\n        )\n    }\n}\nlet http = new httpFetch();\nexport {http}</code></pre></div>","frontmatter":{"title":"ajax和fetch的异同和封装实现","date":"February 10, 2019","description":null}},"previous":{"fields":{"slug":"/js异步操作机制/"},"frontmatter":{"title":"js异步操作机制"}},"next":null},"pageContext":{"id":"a96525ee-d35b-519f-b6c5-8485a59c20b5","previousPostId":"35325c18-69f7-52ee-a324-84c81d1ac78e","nextPostId":null}},"staticQueryHashes":["2841359383","916993862"]}